<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Iterative Cube Truncation Simulator</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0d10; color: #e6e9ef; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto; }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
    header { padding: 10px 14px; display: flex; gap: 12px; align-items: center; border-bottom: 1px solid #1e232b; background: #0f1216; }
    header h1 { font-size: 16px; font-weight: 600; margin: 0; letter-spacing: .25px; }
    header .sub { opacity: .7; font-size: 12px; }
    #canvas { width: 100%; height: 100%; display: block; }
    .hud { position: absolute; top: 180px; right: 12px; background: rgba(15,18,22,.72); backdrop-filter: blur(6px); padding: 10px 12px; border: 1px solid #222831; border-radius: 12px; font-size: 12px; line-height: 1.4; min-width: 220px; }
    .hud code { background: #11151b; padding: 2px 6px; border-radius: 6px; }
    .footer { position: absolute; left: 12px; bottom: 12px; opacity: .6; font-size: 12px; }
    a { color: #7dd3fc; text-decoration: none; }
    .err { position:absolute; left:12px; top:56px; background:#2b1111; color:#ffd4d4; padding:8px 10px; border:1px solid #512020; border-radius:8px; font-size:12px; max-width: 50ch; display:none; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Iterative Cube Truncation Simulator</h1>
      <div class="sub">Cut corners toward the center, repeatedly — watch the shape round towards a sphere.</div>
    </header>
    <div id="viewport" style="position:relative;">
      <canvas id="canvas"></canvas>
      <div class="hud" id="hud"></div>
      <div class="err" id="err"></div>
      <div class="footer">Drag to orbit • Scroll to zoom • Shift+Drag to pan</div>
    </div>
  </div>

  <!-- Three.js and helpers -->
  <script src="https://unpkg.com/three@0.144.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.144.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/lil-gui@0.19.2/dist/lil-gui.umd.min.js"></script>

  <script>
    const showError = (msg)=>{ const e=document.getElementById('err'); e.style.display='block'; e.textContent = msg; console.error(msg); };

    // -------- Math helpers for planes & polyhedron intersection --------
    class Plane {
      constructor(normal, constant) { // n·x = c, keep side n·x <= c (i.e., inside)
        this.n = new THREE.Vector3().copy(normal).normalize();
        this.c = constant;
      }
      dist(x) { return this.n.dot(x) - this.c; }
    }

    function solve3(A, b) { // Robust 3x3 solver with partial pivoting (rows = vectors)
      // Build augmented matrix
      const M = [
        [A[0].x, A[0].y, A[0].z, b[0]],
        [A[1].x, A[1].y, A[1].z, b[1]],
        [A[2].x, A[2].y, A[2].z, b[2]],
      ];
      // Pivoted Gaussian elimination
      for (let col=0; col<3; col++){
        // find pivot
        let piv = col; let best = Math.abs(M[col][col]);
        for (let r=col+1; r<3; r++){ const val = Math.abs(M[r][col]); if (val>best){best=val;piv=r;} }
        if (best < 1e-10) return null;
        if (piv !== col) { const tmp=M[col]; M[col]=M[piv]; M[piv]=tmp; }
        // normalize row
        const f = M[col][col];
        for (let c=col; c<4; c++) M[col][c] /= f;
        // eliminate others
        for (let r=0; r<3; r++) if (r!==col){
          const m = M[r][col];
          for (let c=col; c<4; c++) M[r][c] -= m * M[col][c];
        }
      }
      return new THREE.Vector3(M[0][3], M[1][3], M[2][3]);
    }

    function uniqueVertices(points, eps=1e-5) {
      const out = [];
      for (const p of points) {
        let found = false;
        for (const q of out) {
          if (p.distanceTo(q) < eps) { found = true; break; }
        }
        if (!found) out.push(p);
      }
      return out;
    }

    function basisFromNormal(n) {
      // Build orthonormal basis (u,v) on plane with normal n
      const u = new THREE.Vector3();
      if (Math.abs(n.x) < 0.9) u.set(1,0,0); else u.set(0,1,0);
      u.sub(n.clone().multiplyScalar(u.dot(n))).normalize();
      const v = new THREE.Vector3().crossVectors(n, u).normalize();
      return {u,v};
    }

    function convexHull2D(points2) { // monotonic chain
      const pts = points2.slice().sort((a,b)=> a.x===b.x? a.y-b.y: a.x-b.x);
      const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
      const lower=[]; for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
      const upper=[]; for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
      upper.pop(); lower.pop();
      return lower.concat(upper); // CCW
    }

    function buildPlanesForIterativeTruncation(depth=0.15, iterations=1, maxCutsPerIteration=null, trackNewPlanes=false) {
      const planes = [];
      const newPlaneIndices = new Set();
      
      // Add starting shape planes
      if (params.startingShape === 'cube') {
        // Cube half-spaces: |x|<=1, |y|<=1, |z|<=1
        planes.push(new Plane(new THREE.Vector3( 1,0,0), 1));
        planes.push(new Plane(new THREE.Vector3(-1,0,0), 1));
        planes.push(new Plane(new THREE.Vector3(0, 1,0), 1));
        planes.push(new Plane(new THREE.Vector3(0,-1,0), 1));
        planes.push(new Plane(new THREE.Vector3(0,0, 1), 1));
        planes.push(new Plane(new THREE.Vector3(0,0,-1), 1));
      } else if (params.startingShape === 'pyramid') {
        // Square pyramid (base at y=-1, apex at y=1)
        planes.push(new Plane(new THREE.Vector3(0,-1,0), 1)); // Base plane y >= -1
        // Four triangular faces
        const norm = 1/Math.sqrt(2); // Normalize for 45-degree faces
        planes.push(new Plane(new THREE.Vector3( norm, norm,0), norm)); // Right face
        planes.push(new Plane(new THREE.Vector3(-norm, norm,0), norm)); // Left face  
        planes.push(new Plane(new THREE.Vector3(0, norm, norm), norm)); // Front face
        planes.push(new Plane(new THREE.Vector3(0, norm,-norm), norm)); // Back face
      }

      for (let k=0; k<iterations; k++) {
        const currentDepth = depth * Math.pow(1.5, k); // 50% increase each iteration
        
        // Get current vertices for this iteration
        const vertices = computePolyhedronVertices(planes);
        if (vertices.length === 0) break; // fully clipped (depth too high)
        
        // Limit planes to prevent exponential growth
        if (planes.length > 100) {
          console.warn(`Stopping at iteration ${k+1}: too many planes (${planes.length})`);
          break;
        }
        
        const newPlanes = [];
        for (const v of vertices) {
          // Create plane facing toward center from this vertex
          const n = v.clone().normalize(); // direction from center toward vertex
          const len = v.length(); // distance from center
          const c = (1 - currentDepth) * len; // move plane toward center by currentDepth
          newPlanes.push(new Plane(n, c));
        }
        
        // If maxCutsPerIteration is specified, limit how many planes we add
        let planesToAdd = newPlanes;
        if (maxCutsPerIteration !== null && k === iterations - 1) {
          // Only limit cuts on the current/last iteration being animated
          planesToAdd = newPlanes.slice(0, maxCutsPerIteration);
        }
        
        // Merge similar planes with more aggressive tolerance for performance
        for (let i = 0; i < planesToAdd.length; i++) {
          const pl = planesToAdd[i];
          let duplicate=false;
          for (const q of planes) {
            if (pl.n.distanceTo(q.n) < 5e-4 && Math.abs(pl.c - q.c) < 5e-3) { duplicate=true; break; }
          }
          if (!duplicate) {
            const planeIndex = planes.length;
            planes.push(pl);
            // Track ONLY the most recent plane (last one added in current animation)
            if (trackNewPlanes && k === iterations - 1 && maxCutsPerIteration !== null) {
              // Only highlight the very last plane added (most recent cut)
              if (i === planesToAdd.length - 1) {
                newPlaneIndices.add(planeIndex);
              }
            }
          }
        }
      }
      return trackNewPlanes ? { planes, newPlaneIndices } : planes;
    }

    function computePolyhedronVertices(planes) {
      const pts = [];
      for (let i=0;i<planes.length;i++){
        for (let j=i+1;j<planes.length;j++){
          for (let k=j+1;k<planes.length;k++){
            const A = [planes[i].n, planes[j].n, planes[k].n];
            const b = [planes[i].c, planes[j].c, planes[k].c];
            const x = solve3(A,b);
            if (!x) continue;
            // Check inside: allow tiny tolerance
            let inside = true;
            for (const pl of planes){ if (pl.n.dot(x) - pl.c > 1e-6){ inside=false; break; } }
            if (inside) pts.push(x);
          }
        }
      }
      return uniqueVertices(pts, 1e-4);
    }

    function buildGeometryFromPlanes(planes, newPlaneIndices = []) {
      const vertices = computePolyhedronVertices(planes);
      if (vertices.length < 4) { throw new Error('No solid remains — try reducing depth or iterations.'); }

      const positions = [];
      const normals = [];

      const oldPositions = [];
      const oldNormals = [];
      const newPositions = [];  
      const newNormals = [];
      
      for (let planeIdx = 0; planeIdx < planes.length; planeIdx++) {
        const pl = planes[planeIdx];
        const isNewPlane = newPlaneIndices.includes(planeIdx);
        
        const onPts = [];
        for (const v of vertices){ if (Math.abs(pl.n.dot(v) - pl.c) < 1e-4) onPts.push(v); }
        if (onPts.length < 3) continue;
        const {u, v:vb} = basisFromNormal(pl.n);
        const pts2 = onPts.map(p=>({ x:p.dot(u), y:p.dot(vb), ref:p }));
        const hull2 = convexHull2D(pts2);
        if (hull2.length < 3) continue;
        const poly = hull2.map(p=> p.ref);
        
        const targetPositions = isNewPlane ? newPositions : oldPositions;
        const targetNormals = isNewPlane ? newNormals : oldNormals;
        
        for (let i=1;i+1<poly.length;i++){
          const a = poly[0], b = poly[i], c = poly[i+1];
          targetPositions.push(a.x, a.y, a.z, b.x, b.y, b.z, c.x, c.y, c.z);
          for (let t=0;t<3;t++) targetNormals.push(pl.n.x, pl.n.y, pl.n.z);
        }
      }

      // If no separation needed, return single geometry
      if (newPositions.length === 0) {
        positions.push(...oldPositions);
        normals.push(...oldNormals);
      } else {
        // Return separate geometries
        const oldGeom = new THREE.BufferGeometry();
        oldGeom.setAttribute('position', new THREE.Float32BufferAttribute(oldPositions, 3));
        oldGeom.setAttribute('normal', new THREE.Float32BufferAttribute(oldNormals, 3));
        
        const newGeom = new THREE.BufferGeometry();
        newGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
        newGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
        
        return { oldGeom, newGeom, hasSeparateGeoms: true };
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
      geom.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
      geom.computeBoundingSphere();
      return geom;
    }

    // -------- Three.js scene --------
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
    function sizeCanvas(){
      const w = window.innerWidth, h = window.innerHeight - 44; // header height
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0d10);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(4.2, 3.2, 4.6);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x111122, 0.8));
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(5,6,3); scene.add(key);
    const rim = new THREE.DirectionalLight(0x88aaff, 0.6); rim.position.set(-4,2,-5); scene.add(rim);

    // Materials
    const mat = new THREE.MeshPhysicalMaterial({
      metalness: 0.0,
      roughness: 0.35,
      clearcoat: 0.6,
      clearcoatRoughness: 0.6,
      transmission: 0.0,
      color: 0x6ba6ff,
      transparent: true,
      opacity: 0.7,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1
    });
    const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff });
    const newSurfaceMat = new THREE.MeshPhysicalMaterial({
      metalness: 0.0,
      roughness: 0.35,
      clearcoat: 0.6,
      clearcoatRoughness: 0.6,
      transmission: 0.0,
      color: 0xff6600, // Orange color
      transparent: true,
      opacity: 0.95,
      depthTest: false, // Render through transparent surfaces
      depthWrite: false, // Don't write to depth buffer
      side: THREE.DoubleSide, // Render both sides
      blending: THREE.AdditiveBlending, // Additive blending for glow effect
      polygonOffset: true,
      polygonOffsetFactor: -2, // Push further forward
      polygonOffsetUnits: -2
    });

    const group = new THREE.Group();
    scene.add(group);

    let mesh = null, wire = null, newSurfaceMesh = null;
    let baseDistance = null; // Store the base camera distance
    
    function calculateShrinkageFactor(iterations) {
      // Calculate how much the geometry shrinks due to truncation
      const depth = params.depthPct / 100;
      let totalShrinkage = 1;
      for (let k = 0; k < iterations; k++) {
        const currentDepth = depth * Math.pow(1.5, k);
        const clampedDepth = Math.min(currentDepth, 0.4);
        const dampingFactor = Math.pow(0.8, k);
        const effectiveDepth = clampedDepth * dampingFactor;
        totalShrinkage *= (1 - effectiveDepth);
      }
      return totalShrinkage;
    }
    
    function adjustCameraZoom() {
      // Store base distance on first call
      if (baseDistance === null) {
        baseDistance = camera.position.length();
      }
      
      let targetShrinkage = 1;
      if (animationState.isAnimating) {
        // Use target iteration shrinkage during animation
        targetShrinkage = calculateShrinkageFactor(animationState.targetIterations);
      } else {
        // Use static iteration shrinkage
        targetShrinkage = calculateShrinkageFactor(params.iterations);
      }
      
      // Adjust camera distance to compensate for shrinkage
      const targetDistance = baseDistance * targetShrinkage;
      const currentDistance = camera.position.length();
      const scaleFactor = targetDistance / currentDistance;
      
      camera.position.multiplyScalar(scaleFactor);
      controls.update();
    }

    function startAnimatedCuts() {
      if (animationState.isAnimating) return;
      
      animationState.isAnimating = true;
      animationState.currentIteration = params.iterations; // Start from the target iteration
      animationState.currentCut = 0;
      animationState.targetIterations = params.iterations;
      animationState.isGlowing = false;
      
      if (params.iterations === 0) {
        // Show cube and finish
        const planes = buildPlanesForIterativeTruncation(0.12, 0);
        const geom = buildGeometryFromPlanes(planes, []);
        updateMesh(geom);
        animationState.isAnimating = false;
        return;
      }
      
      // Start by showing the END state of the previous iteration with SIZE SCALING applied
      const depth = params.depthPct / 100;
      const startingIteration = params.iterations - 1; // Previous iteration's END state
      const basePlanes = buildPlanesForIterativeTruncation(depth, startingIteration);
      const baseGeom = buildGeometryFromPlanes(basePlanes, []);
      
      // Show the base state and apply zoom
      updateMesh(baseGeom);
      adjustCameraZoom(); // Adjust zoom for animation
      
      // Start cutting the current iteration  
      setTimeout(animateNextCut, params.cutSpeed);
    }
    
    function animateNextCut() {
      if (!animationState.isAnimating) return;
      
      const depth = params.depthPct / 100;
      
      if (!animationState.isGlowing) {
        // Make the cut and start glowing
        animationState.currentCut++;
        
        // Get planes for current state with new plane tracking  
        const result = buildPlanesForIterativeTruncation(depth, animationState.currentIteration, animationState.currentCut, true);
        const planes = result.planes;
        const newPlaneIndices = Array.from(result.newPlaneIndices);
        
        try {
          const geom = buildGeometryFromPlanes(planes, newPlaneIndices);
          updateMeshWithNewSurfaces(geom);
          
          // Start glow phase
          animationState.isGlowing = true;
          startGlowEffect();
          
          // After glow duration, fade out orange and continue
          setTimeout(() => {
            animationState.isGlowing = false;
            // Remove orange surfaces and show normal geometry
            const geom = buildGeometryFromPlanes(planes, []);
            updateMesh(geom);
            scheduleNextCut();
          }, params.cutSpeed); // Wait for full glow cycle
          
        } catch (e) {
          showError(e.message || String(e));
          animationState.isAnimating = false;
        }
      }
    }
    
    function startGlowEffect() {
      if (!newSurfaceMesh) return;
      
      // Animate the opacity of the orange material - same as cutSpeed duration
      const startTime = Date.now();
      const duration = params.cutSpeed; // Same duration as cutSpeed
      
      function updateGlow() {
        if (!animationState.isGlowing || !newSurfaceMesh) return;
        
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Create a sine wave for smooth fade in/out
        const glowIntensity = Math.sin(progress * Math.PI);
        const opacity = 0.8 + (0.2 * glowIntensity); // Oscillate between 0.8 and 1.0
        
        newSurfaceMesh.material.opacity = opacity;
        
        if (progress < 1 && animationState.isGlowing) {
          requestAnimationFrame(updateGlow);
        } else {
          // Reset to normal opacity
          if (newSurfaceMesh) newSurfaceMesh.material.opacity = 0.8;
        }
      }
      
      updateGlow();
    }
    
    function scheduleNextCut() {
      // Get vertices for previous iteration to know how many cuts are possible
      const depth = params.depthPct / 100;
      const iterPlanes = buildPlanesForIterativeTruncation(depth, animationState.currentIteration - 1);
      const vertices = computePolyhedronVertices(iterPlanes);
      
      // Check if we've finished all cuts for this iteration
      if (animationState.currentCut >= vertices.length) {
        // We've finished the current iteration, stop animating
        animationState.isAnimating = false;
        return;
      }
      
      // Schedule next cut (no extra delay since glow already took cutSpeed time)
      setTimeout(animateNextCut, params.cutSpeed);
    }
    
    function updateMeshWithNewSurfaces(geom) {
      if (mesh) { group.remove(mesh); mesh.geometry.dispose(); }
      if (wire) { group.remove(wire); wire.geometry.dispose(); }
      if (newSurfaceMesh) { group.remove(newSurfaceMesh); newSurfaceMesh.geometry.dispose(); }

      // No more complex scaling - use natural geometry size
      const scaleFactor = 1;

      if (geom.hasSeparateGeoms) {
        // Create mesh for old surfaces (blue)
        if (geom.oldGeom.getAttribute('position').count > 0) {
          mesh = new THREE.Mesh(geom.oldGeom, mat);
          mesh.rotation.order = 'ZYX';
          mesh.rotation.z = Math.PI / 4;
          mesh.rotation.x = Math.atan(Math.SQRT1_2);
          mesh.scale.setScalar(scaleFactor);
          group.add(mesh);
        }

        // Create mesh for new surfaces (orange) - add after main mesh for proper rendering order
        if (geom.newGeom.getAttribute('position').count > 0) {
          newSurfaceMesh = new THREE.Mesh(geom.newGeom, newSurfaceMat);
          newSurfaceMesh.rotation.order = 'ZYX';
          newSurfaceMesh.rotation.z = Math.PI / 4;
          newSurfaceMesh.rotation.x = Math.atan(Math.SQRT1_2);
          newSurfaceMesh.scale.setScalar(scaleFactor);
          newSurfaceMesh.renderOrder = 1; // Render after main mesh
          group.add(newSurfaceMesh);
        }

        // Create wireframe for both
        const combinedGeom = new THREE.BufferGeometry();
        const positions = [];
        const oldPos = geom.oldGeom.getAttribute('position');
        const newPos = geom.newGeom.getAttribute('position');
        
        if (oldPos) positions.push(...oldPos.array);
        if (newPos) positions.push(...newPos.array);
        
        combinedGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const edges = new THREE.EdgesGeometry(combinedGeom, 1);
        wire = new THREE.LineSegments(edges, wireMat);
        wire.rotation.order = 'ZYX';
        wire.rotation.z = Math.PI / 4;
        wire.rotation.x = Math.atan(Math.SQRT1_2);
        wire.scale.setScalar(scaleFactor);
        group.add(wire);

        updateHUD(combinedGeom);
      } else {
        // Single geometry - use regular mesh
        mesh = new THREE.Mesh(geom, mat);
        mesh.rotation.order = 'ZYX';
        mesh.rotation.z = Math.PI / 4;
        mesh.rotation.x = Math.atan(Math.SQRT1_2);
        mesh.scale.setScalar(scaleFactor);
        group.add(mesh);

        const edges = new THREE.EdgesGeometry(geom, 1);
        wire = new THREE.LineSegments(edges, wireMat);
        wire.rotation.copy(mesh.rotation);
        wire.scale.setScalar(scaleFactor);
        group.add(wire);

        updateHUD(geom);
      }
    }
    
    function updateMesh(geom) {
      if (mesh) { group.remove(mesh); mesh.geometry.dispose(); }
      if (wire) { group.remove(wire); wire.geometry.dispose(); }
      if (newSurfaceMesh) { group.remove(newSurfaceMesh); newSurfaceMesh.geometry.dispose(); }

      // No more complex scaling - use natural geometry size
      const scaleFactor = 1;

      mesh = new THREE.Mesh(geom, mat);
      mesh.rotation.order = 'ZYX';
      mesh.rotation.z = Math.PI / 4;
      mesh.rotation.x = Math.atan(Math.SQRT1_2);
      mesh.scale.setScalar(scaleFactor);
      group.add(mesh);

      const edges = new THREE.EdgesGeometry(geom, 1);
      wire = new THREE.LineSegments(edges, wireMat);
      wire.rotation.copy(mesh.rotation);
      wire.scale.setScalar(scaleFactor);
      group.add(wire);

      updateHUD(geom);
    }

    function rebuild() {
      // Stop any current animation
      animationState.isAnimating = false;
      
      if (params.animateCuts && params.iterations > 0) {
        startAnimatedCuts();
        return;
      }
      
      try {
        const depth = params.depthPct / 100;
        const iters = params.iterations;
        if (depth <= 0 || depth >= 0.5) {
          // depth >= 0.5 would remove all vertices in one round on a unit cube
          showError('Choose a cut depth between 0 and 50%.');
        } else { document.getElementById('err').style.display='none'; }

        const planes = buildPlanesForIterativeTruncation(depth, iters);
        const geom = buildGeometryFromPlanes(planes);
        updateMesh(geom);
        adjustCameraZoom(); // Adjust zoom for static display
      } catch (e) {
        showError(e.message || String(e));
      }
    }

    function updateHUD(geom){
      geom.computeBoundingBox();
      const bb = geom.boundingBox;
      const size = new THREE.Vector3(); bb.getSize(size);
      const vcount = geom.getAttribute('position').count;
      const fcount = vcount / 3;
      
      if (animationState.isAnimating) {
        // Show only progress bar during animation
        const depth = params.depthPct / 100;
        // Get vertices from the starting state of current iteration (previous iteration result)
        const startingIteration = animationState.currentIteration - 1;
        const iterPlanes = buildPlanesForIterativeTruncation(depth, startingIteration);
        const vertices = computePolyhedronVertices(iterPlanes);
        const totalCuts = vertices.length; // Don't cap at 8 - use actual vertex count
        const remaining = totalCuts - animationState.currentCut;
        const progress = (animationState.currentCut / totalCuts) * 100;
        
        document.getElementById('hud').innerHTML = `
          <div><strong>Animation Progress</strong></div>
          <div>Iteration: <code>${animationState.currentIteration}</code> of <code>${animationState.targetIterations}</code></div>
          <div>Cuts: <code>${animationState.currentCut}</code> of <code>${totalCuts}</code> (${remaining} remaining)</div>
          <div style="background:#222831;height:8px;border-radius:4px;margin:6px 0;overflow:hidden;">
            <div style="background:#7dd3fc;height:100%;width:${progress}%;border-radius:4px;transition:width 0.3s ease;"></div>
          </div>`;
      } else {
        // Hide HUD when not animating
        document.getElementById('hud').innerHTML = '';
      }
    }

    const params = {
      depthPct: 10,          // percentage of distance from vertex to center removed each round
      iterations: 1,
      autoRotate: true,
      animateCuts: true,
      cutSpeed: 500,         // milliseconds between cuts
      startingShape: 'cube', // 'cube' or 'pyramid'
      resetView: () => { camera.position.set(4.2,3.2,4.6); controls.target.set(0,0,0); controls.update(); },
    };
    
    let animationState = {
      isAnimating: false,
      currentIteration: 0,
      currentCut: 0,
      vertices: [],
      targetIterations: 0,
      newPlaneIndices: new Set(), // Track which planes are newly added
      baseIteration: 0, // Base iteration to start from for current animation
      isGlowing: false,
      targetScaling: false // Flag to use target iteration scaling
    };

    const gui = new lil.GUI({ title: 'Controls' });
    gui.add(params, 'startingShape', ['cube', 'pyramid']).name('Starting shape').onChange(rebuild);
    gui.add(params, 'depthPct', 0.1, 45, 0.1).name('Cut depth %').onChange(rebuild);
    gui.add(params, 'iterations', 0, 8, 1).name('Iterations').onChange(rebuild);
    gui.add(params, 'animateCuts').name('Animate cuts');
    gui.add(params, 'cutSpeed', 100, 2000, 50).name('Cut speed (ms)');
    gui.add(params, 'autoRotate').name('Auto-rotate');
    gui.add(params, 'resetView').name('Reset View');

    // Build initial
    rebuild();

    // Animate
    function animate(){
      requestAnimationFrame(animate);
      if (params.autoRotate && mesh){ group.rotation.y += 0.005; }
      controls.update();
      renderer.render(scene, camera);
    }

    sizeCanvas();
    animate();

    // Resize
    window.addEventListener('resize', sizeCanvas);
  </script>
</body>
</html>
