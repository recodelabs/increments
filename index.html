<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Iterative Cube Truncation Simulator</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0d10; color: #e6e9ef; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto; }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
    header { padding: 10px 14px; display: flex; gap: 12px; align-items: center; border-bottom: 1px solid #1e232b; background: #0f1216; }
    header h1 { font-size: 16px; font-weight: 600; margin: 0; letter-spacing: .25px; }
    header .sub { opacity: .7; font-size: 12px; }
    #canvas { width: 100%; height: 100%; display: block; }
    .hud { position: absolute; top: 180px; right: 12px; background: rgba(15,18,22,.72); backdrop-filter: blur(6px); padding: 10px 12px; border: 1px solid #222831; border-radius: 12px; font-size: 12px; line-height: 1.4; min-width: 220px; }
    .hud code { background: #11151b; padding: 2px 6px; border-radius: 6px; }
    .footer { position: absolute; left: 12px; bottom: 12px; opacity: .6; font-size: 12px; }
    a { color: #7dd3fc; text-decoration: none; }
    .err { position:absolute; left:12px; top:56px; background:#2b1111; color:#ffd4d4; padding:8px 10px; border:1px solid #512020; border-radius:8px; font-size:12px; max-width: 50ch; display:none; }
    
    /* Popup styles */
    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }
    .popup {
      background: #1a1d21;
      border: 1px solid #2a2f38;
      border-radius: 12px;
      padding: 24px;
      min-width: 320px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    .popup h2 {
      margin: 0 0 20px 0;
      font-size: 20px;
      color: #e6e9ef;
      font-weight: 600;
    }
    .popup-field {
      margin-bottom: 16px;
    }
    .popup-field label {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      color: #9ca3af;
      font-weight: 500;
    }
    .popup-field select,
    .popup-field input {
      width: 100%;
      background: #0f1216;
      border: 1px solid #2a2f38;
      border-radius: 6px;
      padding: 8px 12px;
      color: #e6e9ef;
      font-size: 14px;
    }
    .popup-field input[type="range"] {
      padding: 4px 0;
    }
    .popup-field .range-value {
      display: inline-block;
      margin-left: 8px;
      color: #7dd3fc;
      font-weight: 600;
      min-width: 40px;
    }
    .popup-buttons {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }
    .popup-button {
      flex: 1;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }
    .popup-button.primary {
      background: #7dd3fc;
      color: #0b0d10;
    }
    .popup-button.primary:hover {
      background: #93dafe;
    }
    .popup-button.secondary {
      background: #2a2f38;
      color: #e6e9ef;
    }
    .popup-button.secondary:hover {
      background: #3a3f48;
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>The Compounding Effect of Incremental Changes</h1>
      <div class="sub">Cut corners toward the center, repeatedly — watch the shape round towards a sphere.</div>
    </header>
    <div id="viewport" style="position:relative;">
      <canvas id="canvas"></canvas>
      <div class="hud" id="hud"></div>
      <div class="err" id="err"></div>
      <div class="footer">Drag to orbit • Scroll to zoom • Shift+Drag to pan</div>
    </div>
  </div>
  
  <!-- Configuration Popup -->
  <div id="configPopup" class="popup-overlay">
    <div class="popup">
      <h2>Incremental Changes</h2>
      <div class="popup-field">
        <label for="popupShape">Starting Shape</label>
        <select id="popupShape">
          <option value="cube">Cube</option>
          <option value="pyramid">Pyramid</option>
          <option value="diamond">Diamond (Octahedron)</option>
          <option value="rectangle">Rectangle</option>
          <option value="parallelogram">Parallelogram</option>
          <option value="cylinder">Cylinder</option>
          <option value="star">Star</option>
          <option value="hexagon">Hexagonal Prism</option>
        </select>
      </div>
      <div class="popup-field">
        <label for="popupDepth">Cut Depth: <span id="depthValue" class="range-value">5%</span></label>
        <input type="range" id="popupDepth" min="1" max="45" value="5" step="1">
      </div>
      <div class="popup-field">
        <label for="popupOpacity">Fill Opacity: <span id="opacityValue" class="range-value">70%</span></label>
        <input type="range" id="popupOpacity" min="0" max="100" value="70" step="1">
      </div>
      <div class="popup-field">
        <label for="popupColor">Shape Color</label>
        <input type="color" id="popupColor" value="#6ba6ff">
      </div>
      <div class="popup-buttons">
        <button id="startAnimation" class="popup-button primary">Start Animation</button>
        <button id="cancelPopup" class="popup-button secondary">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Three.js and helpers -->
  <script src="https://unpkg.com/three@0.144.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.144.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/lil-gui@0.19.2/dist/lil-gui.umd.min.js"></script>

  <script>
    const showError = (msg)=>{ const e=document.getElementById('err'); e.style.display='block'; e.textContent = msg; console.error(msg); };

    // -------- Math helpers for planes & polyhedron intersection --------
    class Plane {
      constructor(normal, constant) { // n·x = c, keep side n·x <= c (i.e., inside)
        this.n = new THREE.Vector3().copy(normal).normalize();
        this.c = constant;
      }
      dist(x) { return this.n.dot(x) - this.c; }
    }

    function solve3(A, b) { // Robust 3x3 solver with partial pivoting (rows = vectors)
      // Build augmented matrix
      const M = [
        [A[0].x, A[0].y, A[0].z, b[0]],
        [A[1].x, A[1].y, A[1].z, b[1]],
        [A[2].x, A[2].y, A[2].z, b[2]]
      ];
      // Pivoted Gaussian elimination
      for (let col=0; col<3; col++){
        // find pivot
        let piv = col; let best = Math.abs(M[col][col]);
        for (let r=col+1; r<3; r++){ const val = Math.abs(M[r][col]); if (val>best){best=val;piv=r;} }
        if (best < 1e-10) return null;
        if (piv !== col) { const tmp=M[col]; M[col]=M[piv]; M[piv]=tmp; }
        // normalize row
        const f = M[col][col];
        for (let c=col; c<4; c++) M[col][c] /= f;
        // eliminate others
        for (let r=0; r<3; r++) if (r!==col){
          const m = M[r][col];
          for (let c=col; c<4; c++) M[r][c] -= m * M[col][c];
        }
      }
      return new THREE.Vector3(M[0][3], M[1][3], M[2][3]);
    }

    function uniqueVertices(points, eps=1e-5) {
      const out = [];
      for (const p of points) {
        let found = false;
        for (const q of out) {
          if (p.distanceTo(q) < eps) { found = true; break; }
        }
        if (!found) out.push(p);
      }
      return out;
    }

    function basisFromNormal(n) {
      // Build orthonormal basis (u,v) on plane with normal n
      const u = new THREE.Vector3();
      if (Math.abs(n.x) < 0.9) u.set(1,0,0); else u.set(0,1,0);
      u.sub(n.clone().multiplyScalar(u.dot(n))).normalize();
      const v = new THREE.Vector3().crossVectors(n, u).normalize();
      return {u,v};
    }

    function convexHull2D(points2) { // monotonic chain
      const pts = points2.slice().sort((a,b)=> a.x===b.x? a.y-b.y: a.x-b.x);
      const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
      const lower=[]; for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
      const upper=[]; for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
      upper.pop(); lower.pop();
      return lower.concat(upper); // CCW
    }

    function buildPlanesForIterativeTruncation(depth=0.15, iterations=1, maxCutsPerIteration=null, trackNewPlanes=false) {
      const planes = [];
      const newPlaneIndices = new Set();
      
      // Add starting shape planes
      if (params.startingShape === 'cube') {
        // Cube half-spaces: |x|<=1, |y|<=1, |z|<=1
        planes.push(new Plane(new THREE.Vector3( 1,0,0), 1));
        planes.push(new Plane(new THREE.Vector3(-1,0,0), 1));
        planes.push(new Plane(new THREE.Vector3(0, 1,0), 1));
        planes.push(new Plane(new THREE.Vector3(0,-1,0), 1));
        planes.push(new Plane(new THREE.Vector3(0,0, 1), 1));
        planes.push(new Plane(new THREE.Vector3(0,0,-1), 1));
      } else if (params.startingShape === 'pyramid') {
        // Square pyramid (base at y=-1, apex at y=1)
        planes.push(new Plane(new THREE.Vector3(0,-1,0), 1)); // Base plane y >= -1
        // Four triangular faces
        const norm = 1/Math.sqrt(2); // Normalize for 45-degree faces
        planes.push(new Plane(new THREE.Vector3( norm, norm,0), norm)); // Right face
        planes.push(new Plane(new THREE.Vector3(-norm, norm,0), norm)); // Left face  
        planes.push(new Plane(new THREE.Vector3(0, norm, norm), norm)); // Front face
        planes.push(new Plane(new THREE.Vector3(0, norm,-norm), norm)); // Back face
      } else if (params.startingShape === 'diamond') {
        // Diamond/Rhombus (octahedron)
        const n = 1/Math.sqrt(3); // Normalize for equidistant faces
        planes.push(new Plane(new THREE.Vector3( n, n, n), 1));
        planes.push(new Plane(new THREE.Vector3( n, n,-n), 1));
        planes.push(new Plane(new THREE.Vector3( n,-n, n), 1));
        planes.push(new Plane(new THREE.Vector3( n,-n,-n), 1));
        planes.push(new Plane(new THREE.Vector3(-n, n, n), 1));
        planes.push(new Plane(new THREE.Vector3(-n, n,-n), 1));
        planes.push(new Plane(new THREE.Vector3(-n,-n, n), 1));
        planes.push(new Plane(new THREE.Vector3(-n,-n,-n), 1));
      } else if (params.startingShape === 'rectangle') {
        // Rectangle (elongated box): wider in x, normal in y, shorter in z
        planes.push(new Plane(new THREE.Vector3( 1,0,0), 1.5)); // Wider in x
        planes.push(new Plane(new THREE.Vector3(-1,0,0), 1.5));
        planes.push(new Plane(new THREE.Vector3(0, 1,0), 1));   // Normal in y
        planes.push(new Plane(new THREE.Vector3(0,-1,0), 1));
        planes.push(new Plane(new THREE.Vector3(0,0, 1), 0.6)); // Shorter in z
        planes.push(new Plane(new THREE.Vector3(0,0,-1), 0.6));
      } else if (params.startingShape === 'parallelogram') {
        // Parallelogram (skewed box)
        const skew = 0.5; // Skew factor
        planes.push(new Plane(new THREE.Vector3( 1, 0, skew).normalize(), 1.2));
        planes.push(new Plane(new THREE.Vector3(-1, 0,-skew).normalize(), 1.2));
        planes.push(new Plane(new THREE.Vector3( skew, 1, 0).normalize(), 1));
        planes.push(new Plane(new THREE.Vector3(-skew,-1, 0).normalize(), 1));
        planes.push(new Plane(new THREE.Vector3(0, 0, 1), 0.8));
        planes.push(new Plane(new THREE.Vector3(0, 0,-1), 0.8));
      } else if (params.startingShape === 'cylinder') {
        // Cylinder (approximated with 12 faces)
        // Top and bottom faces
        planes.push(new Plane(new THREE.Vector3(0, 1, 0), 1));
        planes.push(new Plane(new THREE.Vector3(0, -1, 0), 1));
        
        // 12 side faces to approximate a cylinder
        const numSides = 12;
        for (let i = 0; i < numSides; i++) {
          const angle = (i * Math.PI * 2) / numSides;
          const nx = Math.cos(angle);
          const nz = Math.sin(angle);
          planes.push(new Plane(new THREE.Vector3(nx, 0, nz), 1));
        }
      } else if (params.startingShape === 'star') {
        // Proper 5-pointed star shape
        // Top and bottom faces
        planes.push(new Plane(new THREE.Vector3(0, 1, 0), 1));
        planes.push(new Plane(new THREE.Vector3(0, -1, 0), 1));
        
        // Create a 5-pointed star with 10 vertical faces
        const numPoints = 5;
        
        // Generate the 10 vertices of the star (alternating outer and inner)
        for (let i = 0; i < numPoints * 2; i++) {
          const angle = (i * Math.PI * 2) / (numPoints * 2) - Math.PI / 2; // Start from top
          const nextAngle = ((i + 1) * Math.PI * 2) / (numPoints * 2) - Math.PI / 2;
          
          // Calculate the midpoint angle between current and next vertex
          const midAngle = (angle + nextAngle) / 2;
          
          // Create a face perpendicular to the midpoint direction
          const nx = Math.cos(midAngle);
          const nz = Math.sin(midAngle);
          
          // Alternate between two distances to create star shape
          const isOuter = i % 2 === 0;
          const distance = isOuter ? 0.6 : 1.3;
          
          planes.push(new Plane(new THREE.Vector3(nx, 0, nz), distance));
        }
      } else if (params.startingShape === 'hexagon') {
        // Hexagonal prism
        // Top and bottom faces
        planes.push(new Plane(new THREE.Vector3(0, 1, 0), 1));
        planes.push(new Plane(new THREE.Vector3(0, -1, 0), 1));
        
        // Six side faces of the hexagon
        for (let i = 0; i < 6; i++) {
          const angle = (i * Math.PI * 2) / 6;
          const nx = Math.cos(angle);
          const nz = Math.sin(angle);
          planes.push(new Plane(new THREE.Vector3(nx, 0, nz), 1));
        }
      }

      for (let k=0; k<iterations; k++) {
        const currentDepth = depth * Math.pow(1.5, k); // 50% increase each iteration
        
        // Get current vertices for this iteration
        const vertices = computePolyhedronVertices(planes);
        if (vertices.length === 0) break; // fully clipped (depth too high)
        
        // Limit planes to prevent exponential growth
        if (planes.length > 200) {
          console.warn(`Stopping at iteration ${k+1}: too many planes (${planes.length})`);
          break;
        }
        
        const newPlanes = [];
        for (const v of vertices) {
          // Create plane facing toward center from this vertex
          const n = v.clone().normalize(); // direction from center toward vertex
          const len = v.length(); // distance from center
          const c = (1 - currentDepth) * len; // move plane toward center by currentDepth
          newPlanes.push(new Plane(n, c));
        }
        
        // If maxCutsPerIteration is specified, limit how many planes we add
        let planesToAdd = newPlanes;
        if (maxCutsPerIteration !== null && k === iterations - 1) {
          // Only limit cuts on the current/last iteration being animated
          planesToAdd = newPlanes.slice(0, maxCutsPerIteration);
        }
        
        // Merge similar planes with more aggressive tolerance for performance
        for (let i = 0; i < planesToAdd.length; i++) {
          const pl = planesToAdd[i];
          let duplicate=false;
          for (const q of planes) {
            if (pl.n.distanceTo(q.n) < 5e-4 && Math.abs(pl.c - q.c) < 5e-3) { duplicate=true; break; }
          }
          if (!duplicate) {
            const planeIndex = planes.length;
            planes.push(pl);
            // Track ONLY the most recent plane (last one added in current animation)
            if (trackNewPlanes && k === iterations - 1 && maxCutsPerIteration !== null) {
              // Only highlight the very last plane added (most recent cut)
              if (i === planesToAdd.length - 1) {
                newPlaneIndices.add(planeIndex);
              }
            }
          }
        }
      }
      return trackNewPlanes ? { planes, newPlaneIndices } : planes;
    }

    function computePolyhedronVertices(planes) {
      const pts = [];
      for (let i=0;i<planes.length;i++){
        for (let j=i+1;j<planes.length;j++){
          for (let k=j+1;k<planes.length;k++){
            const A = [planes[i].n, planes[j].n, planes[k].n];
            const b = [planes[i].c, planes[j].c, planes[k].c];
            const x = solve3(A,b);
            if (!x) continue;
            // Check inside: allow tiny tolerance
            let inside = true;
            for (const pl of planes){ if (pl.n.dot(x) - pl.c > 1e-6){ inside=false; break; } }
            if (inside) pts.push(x);
          }
        }
      }
      return uniqueVertices(pts, 1e-4);
    }

    function buildGeometryFromPlanes(planes, newPlaneIndices = []) {
      const vertices = computePolyhedronVertices(planes);
      if (vertices.length < 4) { throw new Error('No solid remains — try reducing depth or iterations.'); }

      const positions = [];
      const normals = [];

      const oldPositions = [];
      const oldNormals = [];
      const newPositions = [];  
      const newNormals = [];
      
      for (let planeIdx = 0; planeIdx < planes.length; planeIdx++) {
        const pl = planes[planeIdx];
        const isNewPlane = newPlaneIndices.includes(planeIdx);
        
        const onPts = [];
        for (const v of vertices){ if (Math.abs(pl.n.dot(v) - pl.c) < 1e-4) onPts.push(v); }
        if (onPts.length < 3) continue;
        const {u, v:vb} = basisFromNormal(pl.n);
        const pts2 = onPts.map(p=>({ x:p.dot(u), y:p.dot(vb), ref:p }));
        const hull2 = convexHull2D(pts2);
        if (hull2.length < 3) continue;
        const poly = hull2.map(p=> p.ref);
        
        const targetPositions = isNewPlane ? newPositions : oldPositions;
        const targetNormals = isNewPlane ? newNormals : oldNormals;
        
        for (let i=1;i+1<poly.length;i++){
          const a = poly[0], b = poly[i], c = poly[i+1];
          targetPositions.push(a.x, a.y, a.z, b.x, b.y, b.z, c.x, c.y, c.z);
          for (let t=0;t<3;t++) targetNormals.push(pl.n.x, pl.n.y, pl.n.z);
        }
      }

      // If no separation needed, return single geometry
      if (newPositions.length === 0) {
        positions.push(...oldPositions);
        normals.push(...oldNormals);
      } else {
        // Return separate geometries
        const oldGeom = new THREE.BufferGeometry();
        oldGeom.setAttribute('position', new THREE.Float32BufferAttribute(oldPositions, 3));
        oldGeom.setAttribute('normal', new THREE.Float32BufferAttribute(oldNormals, 3));
        
        const newGeom = new THREE.BufferGeometry();
        newGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
        newGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
        
        return { oldGeom, newGeom, hasSeparateGeoms: true };
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
      geom.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
      geom.computeBoundingSphere();
      return geom;
    }

    // -------- Three.js scene --------
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
    function sizeCanvas(){
      const w = window.innerWidth, h = window.innerHeight - 44; // header height
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0d10);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(4.2, 3.2, 4.6);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x111122, 0.8));
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(5,6,3); scene.add(key);
    const rim = new THREE.DirectionalLight(0x88aaff, 0.6); rim.position.set(-4,2,-5); scene.add(rim);

    // Materials
    const mat = new THREE.MeshPhysicalMaterial({
      metalness: 0.0,
      roughness: 0.35,
      clearcoat: 0.6,
      clearcoatRoughness: 0.6,
      transmission: 0.0,
      color: 0x6ba6ff,
      transparent: true,
      opacity: 0.7, // This will be overridden by params.fillOpacity
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1
    });
    const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff });
    const newSurfaceMat = new THREE.MeshPhysicalMaterial({
      metalness: 0.0,
      roughness: 0.35,
      clearcoat: 0.6,
      clearcoatRoughness: 0.6,
      transmission: 0.0,
      color: 0xff6600, // Orange color
      transparent: true,
      opacity: 0.95,
      depthTest: false, // Render through transparent surfaces
      depthWrite: false, // Don't write to depth buffer
      side: THREE.DoubleSide, // Render both sides
      blending: THREE.AdditiveBlending, // Additive blending for glow effect
      polygonOffset: true,
      polygonOffsetFactor: -2, // Push further forward
      polygonOffsetUnits: -2
    });

    const group = new THREE.Group();
    scene.add(group);

    let mesh = null, wire = null, newSurfaceMesh = null;
    let baseDistance = null; // Store the base camera distance
    
    function calculateShrinkageFactor(iterations) {
      // Calculate how much the geometry shrinks due to truncation
      const depth = params.depthPct / 100;
      let totalShrinkage = 1;
      for (let k = 0; k < iterations; k++) {
        const currentDepth = depth * Math.pow(1.5, k);
        const clampedDepth = Math.min(currentDepth, 0.4);
        const dampingFactor = Math.pow(0.8, k);
        const effectiveDepth = clampedDepth * dampingFactor;
        totalShrinkage *= (1 - effectiveDepth);
      }
      return totalShrinkage;
    }
    
    function adjustCameraZoom() {
      // Store base distance on first call
      if (baseDistance === null) {
        baseDistance = camera.position.length();
      }
      
      let targetShrinkage = 1;
      if (animationState.isAnimating) {
        // Use target iteration shrinkage during animation
        targetShrinkage = calculateShrinkageFactor(animationState.targetIterations);
      } else {
        // Use static iteration shrinkage
        targetShrinkage = calculateShrinkageFactor(params.iterations);
      }
      
      // Adjust camera distance to compensate for shrinkage
      const targetDistance = baseDistance * targetShrinkage;
      const currentDistance = camera.position.length();
      const scaleFactor = targetDistance / currentDistance;
      
      camera.position.multiplyScalar(scaleFactor);
      controls.update();
    }

    function toggleAutoTransition() {
      if (!params.autoTransitionEnabled) {
        // Show popup to configure and start
        showConfigPopup();
      } else {
        // Pause the animation
        params.autoTransitionEnabled = false;
        updateAutoTransitionButton();
        
        // Stop auto transition and any current animation
        animationState.isAutoTransitioning = false;
        animationState.isAnimating = false;
        animationState.isGlowing = false;
        animationState.onAnimationComplete = null;
      }
    }
    
    function showConfigPopup() {
      const popup = document.getElementById('configPopup');
      popup.classList.remove('hidden');
      
      // Set current values
      document.getElementById('popupShape').value = params.startingShape;
      document.getElementById('popupDepth').value = params.depthPct;
      document.getElementById('depthValue').textContent = params.depthPct + '%';
      document.getElementById('popupOpacity').value = params.fillOpacity;
      document.getElementById('opacityValue').textContent = params.fillOpacity + '%';
      document.getElementById('popupColor').value = params.shapeColor;
    }
    
    function hideConfigPopup() {
      const popup = document.getElementById('configPopup');
      popup.classList.add('hidden');
    }
    
    function startAutoTransition() {
      if (!params.autoTransitionEnabled) return;
      
      // Auto transition from current state through iterations 2, 3, 4
      animationState.isAutoTransitioning = true;
      animationState.transitionIterations = [2, 3, 4];
      animationState.currentTransitionIndex = 0;
      
      // Set initial cut speeds for each iteration
      animationState.cutSpeeds = {
        1: params.cutSpeed || 250,  // Use current cutSpeed for iteration 1
        2: 100,
        3: 25,
        4: 10
      };
      
      // Start with iteration 1 if not already there
      params.iterations = 1;
      rebuild();
      
      // Wait a shorter moment then start transitioning
      setTimeout(() => {
        if (params.autoTransitionEnabled) {
          transitionToNextIteration();
        }
      }, 2000); // Reduced from 10 seconds to 2 seconds
    }
    
    function transitionToNextIteration() {
      if (!animationState.isAutoTransitioning || !params.autoTransitionEnabled ||
          animationState.currentTransitionIndex >= animationState.transitionIterations.length) {
        // Finished all transitions or auto-transition disabled
        animationState.isAutoTransitioning = false;
        // If we finished all transitions, restart from beginning
        if (params.autoTransitionEnabled && animationState.currentTransitionIndex >= animationState.transitionIterations.length) {
          setTimeout(() => {
            if (params.autoTransitionEnabled) {
              startAutoTransition();
            }
          }, 2000); // Wait 2 seconds before restarting
        }
        return;
      }
      
      const targetIteration = animationState.transitionIterations[animationState.currentTransitionIndex];
      animationState.currentTransitionIndex++;
      
      
      // Update params and cut speed for this iteration
      params.iterations = targetIteration;
      params.cutSpeed = animationState.cutSpeeds[targetIteration];
      params.animateCuts = true; // Ensure animation is enabled
      
      // Update GUI to reflect new values
      if (window.iterController) {
        window.iterController.updateDisplay();
      }
      if (window.speedController) {
        window.speedController.updateDisplay();
      }
      
      // Stop any current animation before starting new one
      animationState.isAnimating = false;
      
      // Start animated cuts for this iteration
      startAnimatedCuts(() => {
        // After this iteration completes, wait then transition to next
        if (animationState.currentTransitionIndex < animationState.transitionIterations.length) {
          setTimeout(() => {
            transitionToNextIteration();
          }, 200); // Reduced pause between iterations
        } else {
          animationState.isAutoTransitioning = false;
        }
      });
    }
    
    function startAnimatedCuts(onComplete) {
      if (animationState.isAnimating) {
        if (onComplete) onComplete(); // Call callback immediately if skipping
        return;
      }
      
      animationState.isAnimating = true;
      animationState.currentIteration = params.iterations; // Start from the target iteration
      animationState.currentCut = 0;
      animationState.targetIterations = params.iterations;
      animationState.isGlowing = false;
      animationState.onAnimationComplete = onComplete; // Store callback
      
      if (params.iterations === 0) {
        // Show cube and finish
        const planes = buildPlanesForIterativeTruncation(0.12, 0);
        const geom = buildGeometryFromPlanes(planes, []);
        updateMesh(geom);
        animationState.isAnimating = false;
        if (onComplete) onComplete();
        return;
      }
      
      // Start by showing the END state of the previous iteration with SIZE SCALING applied
      const depth = params.depthPct / 100;
      const startingIteration = params.iterations - 1; // Previous iteration's END state
      const basePlanes = buildPlanesForIterativeTruncation(depth, startingIteration);
      const baseGeom = buildGeometryFromPlanes(basePlanes, []);
      
      // Show the base state and apply zoom
      updateMesh(baseGeom);
      adjustCameraZoom(); // Adjust zoom for animation
      
      // Start cutting the current iteration  
      setTimeout(animateNextCut, params.cutSpeed);
    }
    
    function animateNextCut() {
      if (!animationState.isAnimating) return;
      
      const depth = params.depthPct / 100;
      
      if (!animationState.isGlowing) {
        // Make the cut and start glowing
        // For iterations 4 and 5, cut more vertices at a time for better performance
        const cutsPerStep = (animationState.currentIteration >= 4) ? 10 : 1;
        animationState.currentCut += cutsPerStep;
        
        // Get planes for current state with new plane tracking  
        const result = buildPlanesForIterativeTruncation(depth, animationState.currentIteration, animationState.currentCut, true);
        const planes = result.planes;
        const newPlaneIndices = Array.from(result.newPlaneIndices);
        
        try {
          const geom = buildGeometryFromPlanes(planes, newPlaneIndices);
          updateMeshWithNewSurfaces(geom);
          
          // For iterations 4 and 5, skip glow effect for performance
          if (animationState.currentIteration >= 4) {
            // Skip glow for iterations 4 and 5, just update directly
            const normalGeom = buildGeometryFromPlanes(planes, []);
            updateMesh(normalGeom);
            // Use requestAnimationFrame for smoother performance
            requestAnimationFrame(() => {
              scheduleNextCut();
            });
          } else {
            // Start glow phase for other iterations
            animationState.isGlowing = true;
            startGlowEffect();
            
            // After glow duration, fade out orange and continue
            setTimeout(() => {
              animationState.isGlowing = false;
              // Remove orange surfaces and show normal geometry
              const geom = buildGeometryFromPlanes(planes, []);
              updateMesh(geom);
              scheduleNextCut();
            }, params.cutSpeed); // Wait for full glow cycle
          }
          
        } catch (e) {
          showError(e.message || String(e));
          animationState.isAnimating = false;
        }
      }
    }
    
    function startGlowEffect() {
      if (!newSurfaceMesh) return;
      
      // Animate the opacity of the orange material - same as cutSpeed duration
      const startTime = Date.now();
      const duration = params.cutSpeed; // Same duration as cutSpeed
      
      function updateGlow() {
        if (!animationState.isGlowing || !newSurfaceMesh) return;
        
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Create a sine wave for smooth fade in/out
        const glowIntensity = Math.sin(progress * Math.PI);
        const opacity = 0.8 + (0.2 * glowIntensity); // Oscillate between 0.8 and 1.0
        
        newSurfaceMesh.material.opacity = opacity;
        
        if (progress < 1 && animationState.isGlowing) {
          requestAnimationFrame(updateGlow);
        } else {
          // Reset to normal opacity
          if (newSurfaceMesh) newSurfaceMesh.material.opacity = 0.8;
        }
      }
      
      updateGlow();
    }
    
    function scheduleNextCut() {
      // Get vertices for previous iteration to know how many cuts are possible
      const depth = params.depthPct / 100;
      const iterPlanes = buildPlanesForIterativeTruncation(depth, animationState.currentIteration - 1);
      const vertices = computePolyhedronVertices(iterPlanes);
      
      
      // Check if we've finished all cuts for this iteration
      if (animationState.currentCut >= vertices.length) {
        // We've finished the current iteration, stop animating
        animationState.isAnimating = false;
        
        // Only call the callback once and then clear it
        if (animationState.onAnimationComplete) {
          const callback = animationState.onAnimationComplete;
          animationState.onAnimationComplete = null; // Clear it before calling to prevent double execution
          callback();
        }
        return;
      }
      
      // Schedule next cut (no extra delay since glow already took cutSpeed time)
      setTimeout(animateNextCut, params.cutSpeed);
    }
    
    function updateMeshWithNewSurfaces(geom) {
      if (mesh) { group.remove(mesh); mesh.geometry.dispose(); }
      if (wire) { group.remove(wire); wire.geometry.dispose(); }
      if (newSurfaceMesh) { group.remove(newSurfaceMesh); newSurfaceMesh.geometry.dispose(); }

      // No more complex scaling - use natural geometry size
      const scaleFactor = 1;

      if (geom.hasSeparateGeoms) {
        // Create mesh for old surfaces (blue)
        if (geom.oldGeom.getAttribute('position').count > 0) {
          mesh = new THREE.Mesh(geom.oldGeom, mat);
          mesh.rotation.order = 'ZYX';
          mesh.rotation.z = Math.PI / 4;
          mesh.rotation.x = Math.atan(Math.SQRT1_2);
          mesh.scale.setScalar(scaleFactor);
          group.add(mesh);
        }

        // Create mesh for new surfaces (orange) - add after main mesh for proper rendering order
        if (geom.newGeom.getAttribute('position').count > 0) {
          newSurfaceMesh = new THREE.Mesh(geom.newGeom, newSurfaceMat);
          newSurfaceMesh.rotation.order = 'ZYX';
          newSurfaceMesh.rotation.z = Math.PI / 4;
          newSurfaceMesh.rotation.x = Math.atan(Math.SQRT1_2);
          newSurfaceMesh.scale.setScalar(scaleFactor);
          newSurfaceMesh.renderOrder = 1; // Render after main mesh
          group.add(newSurfaceMesh);
        }

        // Create wireframe for both
        const combinedGeom = new THREE.BufferGeometry();
        const positions = [];
        const oldPos = geom.oldGeom.getAttribute('position');
        const newPos = geom.newGeom.getAttribute('position');
        
        if (oldPos) positions.push(...oldPos.array);
        if (newPos) positions.push(...newPos.array);
        
        combinedGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const edges = new THREE.EdgesGeometry(combinedGeom, 1);
        wire = new THREE.LineSegments(edges, wireMat);
        wire.rotation.order = 'ZYX';
        wire.rotation.z = Math.PI / 4;
        wire.rotation.x = Math.atan(Math.SQRT1_2);
        wire.scale.setScalar(scaleFactor);
        group.add(wire);

        updateHUD(combinedGeom);
      } else {
        // Single geometry - use regular mesh
        mesh = new THREE.Mesh(geom, mat);
        mesh.rotation.order = 'ZYX';
        mesh.rotation.z = Math.PI / 4;
        mesh.rotation.x = Math.atan(Math.SQRT1_2);
        mesh.scale.setScalar(scaleFactor);
        group.add(mesh);

        const edges = new THREE.EdgesGeometry(geom, 1);
        wire = new THREE.LineSegments(edges, wireMat);
        wire.rotation.copy(mesh.rotation);
        wire.scale.setScalar(scaleFactor);
        group.add(wire);

        updateHUD(geom);
      }
    }
    
    function updateMesh(geom) {
      if (mesh) { group.remove(mesh); mesh.geometry.dispose(); }
      if (wire) { group.remove(wire); wire.geometry.dispose(); }
      if (newSurfaceMesh) { group.remove(newSurfaceMesh); newSurfaceMesh.geometry.dispose(); }

      // No more complex scaling - use natural geometry size
      const scaleFactor = 1;

      mesh = new THREE.Mesh(geom, mat);
      mesh.rotation.order = 'ZYX';
      mesh.rotation.z = Math.PI / 4;
      mesh.rotation.x = Math.atan(Math.SQRT1_2);
      mesh.scale.setScalar(scaleFactor);
      group.add(mesh);

      const edges = new THREE.EdgesGeometry(geom, 1);
      wire = new THREE.LineSegments(edges, wireMat);
      wire.rotation.copy(mesh.rotation);
      wire.scale.setScalar(scaleFactor);
      group.add(wire);

      updateHUD(geom);
    }

    function rebuild() {
      // Stop any current animation
      animationState.isAnimating = false;
      
      if (params.animateCuts && params.iterations > 0) {
        startAnimatedCuts(null); // No callback for regular rebuilds
        return;
      }
      
      try {
        const depth = params.depthPct / 100;
        const iters = params.iterations;
        if (depth <= 0 || depth >= 0.5) {
          // depth >= 0.5 would remove all vertices in one round on a unit cube
          showError('Choose a cut depth between 0 and 50%.');
        } else { document.getElementById('err').style.display='none'; }

        const planes = buildPlanesForIterativeTruncation(depth, iters);
        const geom = buildGeometryFromPlanes(planes);
        updateMesh(geom);
        adjustCameraZoom(); // Adjust zoom for static display
      } catch (e) {
        showError(e.message || String(e));
      }
    }

    function updateHUD(geom){
      geom.computeBoundingBox();
      const bb = geom.boundingBox;
      const size = new THREE.Vector3(); bb.getSize(size);
      const vcount = geom.getAttribute('position').count;
      const fcount = vcount / 3;
      
      if (animationState.isAnimating) {
        // Show only progress bar during animation
        const depth = params.depthPct / 100;
        // Get vertices from the starting state of current iteration (previous iteration result)
        const startingIteration = animationState.currentIteration - 1;
        const iterPlanes = buildPlanesForIterativeTruncation(depth, startingIteration);
        const vertices = computePolyhedronVertices(iterPlanes);
        const totalCuts = vertices.length; // Don't cap at 8 - use actual vertex count
        const remaining = totalCuts - animationState.currentCut;
        const progress = (animationState.currentCut / totalCuts) * 100;
        
        document.getElementById('hud').innerHTML = `
          <div><strong>Animation Progress</strong></div>
          <div>Iteration: <code>${animationState.currentIteration}</code> of <code>${animationState.targetIterations}</code></div>
          <div>Cuts: <code>${animationState.currentCut}</code> of <code>${totalCuts}</code> (${remaining} remaining)</div>
          <div style="background:#222831;height:8px;border-radius:4px;margin:6px 0;overflow:hidden;">
            <div style="background:#7dd3fc;height:100%;width:${progress}%;border-radius:4px;transition:width 0.3s ease;"></div>
          </div>`;
      } else {
        // Hide HUD when not animating
        document.getElementById('hud').innerHTML = '';
      }
    }

    const params = {
      depthPct: 5,          // percentage of distance from vertex to center removed each round
      iterations: 1,
      autoRotate: true,
      animateCuts: true,
      cutSpeed: 250,         // milliseconds between cuts
      startingShape: 'cube', // 'cube' or 'pyramid'
      fillOpacity: 70,       // opacity percentage for the shape fill
      shapeColor: '#6ba6ff', // Default blue color
      resetView: () => { camera.position.set(4.2,3.2,4.6); controls.target.set(0,0,0); controls.update(); },
      autoTransitionEnabled: false,  // Start with animation disabled
      toggleAutoTransition: () => { toggleAutoTransition(); }
    };
    
    let animationState = {
      isAnimating: false,
      currentIteration: 0,
      currentCut: 0,
      vertices: [],
      targetIterations: 0,
      newPlaneIndices: new Set(), // Track which planes are newly added
      baseIteration: 0, // Base iteration to start from for current animation
      isGlowing: false,
      targetScaling: false, // Flag to use target iteration scaling
      isAutoTransitioning: false,
      transitionIterations: [],
      currentTransitionIndex: 0,
      cutSpeeds: {},
      onAnimationComplete: null
    };

    const gui = new lil.GUI({ title: 'Controls' });
    gui.add(params, 'startingShape', ['cube', 'pyramid', 'diamond', 'rectangle', 'parallelogram', 'cylinder', 'star', 'hexagon']).name('Starting shape').onChange(rebuild);
    gui.add(params, 'depthPct', 0.1, 45, 0.1).name('Cut depth %').onChange(rebuild);
    window.iterController = gui.add(params, 'iterations', 0, 4, 1).name('Iterations').onChange(() => {
      if (!animationState.isAutoTransitioning) rebuild();
    });
    gui.add(params, 'animateCuts').name('Animate cuts');
    window.speedController = gui.add(params, 'cutSpeed', 50, 2000, 50).name('Cut speed (ms)');
    gui.add(params, 'fillOpacity', 0, 100, 1).name('Fill opacity %').onChange(() => {
      // Update material opacity
      mat.opacity = params.fillOpacity / 100;
    });
    gui.addColor(params, 'shapeColor').name('Shape color').onChange(() => {
      // Update material color
      mat.color.set(params.shapeColor);
    });
    gui.add(params, 'autoRotate').name('Auto-rotate');
    gui.add(params, 'resetView').name('Reset View');
    window.autoTransitionButton = gui.add(params, 'toggleAutoTransition').name('View Animation');
    
    // Update button color and text based on state
    function updateAutoTransitionButton() {
      const button = window.autoTransitionButton?.domElement?.querySelector('.name');
      if (button) {
        button.style.color = params.autoTransitionEnabled ? '#7dd3fc' : '#e6e9ef';
        button.style.fontWeight = params.autoTransitionEnabled ? '600' : '400';
        button.textContent = params.autoTransitionEnabled ? 'Pause Animation' : 'View Animation';
      }
    }

    // Setup popup event handlers
    document.getElementById('popupDepth').addEventListener('input', (e) => {
      document.getElementById('depthValue').textContent = e.target.value + '%';
    });
    
    document.getElementById('popupOpacity').addEventListener('input', (e) => {
      document.getElementById('opacityValue').textContent = e.target.value + '%';
    });
    
    document.getElementById('startAnimation').addEventListener('click', () => {
      // Get values from popup
      params.startingShape = document.getElementById('popupShape').value;
      params.depthPct = parseInt(document.getElementById('popupDepth').value);
      params.fillOpacity = parseInt(document.getElementById('popupOpacity').value);
      params.shapeColor = document.getElementById('popupColor').value;
      
      // Update material opacity and color
      mat.opacity = params.fillOpacity / 100;
      mat.color.set(params.shapeColor);
      
      // Hide popup and start animation
      hideConfigPopup();
      params.autoTransitionEnabled = true;
      updateAutoTransitionButton();
      
      // Rebuild with new settings and start
      rebuild();
      startAutoTransition();
    });
    
    document.getElementById('cancelPopup').addEventListener('click', () => {
      hideConfigPopup();
    });
    
    // Build initial
    rebuild();
    
    // Update button initially
    setTimeout(() => {
      updateAutoTransitionButton();
      // Show popup on page load
      showConfigPopup();
    }, 500);

    // Animate
    function animate(){
      requestAnimationFrame(animate);
      if (params.autoRotate && mesh){ group.rotation.y += 0.005; }
      controls.update();
      renderer.render(scene, camera);
    }

    sizeCanvas();
    animate();

    // Resize
    window.addEventListener('resize', sizeCanvas);
  </script>
</body>
</html>
